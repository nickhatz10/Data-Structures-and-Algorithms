# -*- coding: utf-8 -*-
"""Leet_Code_Problems.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18k0XQuuVC0R67JvaiDvO69jzlv7ChlXQ
"""

# 217. Contains Duplicate
# Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

from collections import Counter
class Duplicate_Nums:
    def containsDuplicate(self, nums):
      # uses a dictionary where the letter is the key and the count of the letter is the value for the nums list
      count_dict = Counter(nums)
      # list comprehension to iterate through the values in the dictionary
      # if a value is greater than or equal to 2, this means that its key is repeated in the nums list
      # so if it is repeated, we will put that value in a list and by the time the iteration is done, 
      # the number of elements in the dups list will represent the number of repeat numbers in the nums list
      dups = [val for val in count_dict.values() if val >= 2]
      # if the dups list is not empty, then we will return True since there are repeating numbers
      if len(dups) > 0:
          return True
      # otherwise we will return false since there are no repeating numbers
      else:
          return False

# 1. Two Sum
# Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
# You may assume that each input would have exactly one solution, and you may not use the same element twice.

class two_sum:
    def twoSum(self, nums, target):
      # create an empty dictionary
      diction = dict()
      # uses enumerate to get the index and the actual number from each number in the nums list
      for i, num in enumerate(nums):
        # if the target number minus the number in nums is not in the dictionary
        # then we will append it in the dictionary with the current number being the key and its index being the value
        if (target - num) not in diction:
            diction[num] = i
        # if it is already in the dictionary, then we found our answer
        # we simply need to subtract the target from the num and get the index of that in the dictionary
        # and then we also return the current index we are on
        else:
            return [diction[target-num], i]

# 242. Valid Anagram
# Given two strings s and t, return true if t is an anagram of s, and false otherwise.
# An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

# import statement to create a dictionary of the count (value) of how many times each letter (key) appears for both string s and string t
from collections import Counter
class Anagram:
    def isAnagram(self, s, t) -> bool:
      # gets a dictionary containing the counts of each letter in string s
      count_s = Counter(s)
      # gets a dictionary containing the counts of each letter in string t
      count_t = Counter(t)
      # if string s is shorter than string t, then we will swap the dictionaries since we want string s to always be the longer string
      if len(s) < len(t):
          count_s, count_t = count_t, count_s
      # iterates through each key in the count dictionary of string s
      print(count_s)
      print(count_t)
      for key in count_s:
        # if the key in the count dictionary of string s does not equal the key in the count dictionary of t, then we return false
        if count_s[key] != count_t[key]:
            return False
      # otherwise we will return true since the letters in both strings match eachother perfectly
      return True

# 566. Reshape the Matrix
# In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data.
# You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix.
# The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.
# If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.

class matrix_reshape:
  def matrixReshape(self, mat, r, c):
    # checks to make sure that operation with given parameters is possible and legal
    # we check this by multiplying the new dimensions and then multiplying the old dimensions to make sure they equal eachother
    if r*c == (len(mat[0]) * len(mat)):

      # if r is equal to 1, then we know that the matrix will have only one row so we can use list comprehensions to take each value
      # in the old matrix and put it into a single list to create the new matrix with one row
      if r == 1:
        return [[item for sublist in mat for item in sublist]]

      # if c is equal to 1, then we know that the matrix will only have 1 column, so each number in the original matrix will be its own row
      # we can again use list comprehension to do this by simply taking each item in the original matrix and putting it into its own list and then putting 
      # these sublists into one big list
      elif c == 1:
        return [[item] for sublist in mat for item in sublist]

      # we go here if neither of the first two conditions are met
      else:
        # we create an empty list
        final_list = []
        # we create a flattened list by taking each element in the whole entire matrix and putting it into one big list
        flat_list = [item for sublist in mat for item in sublist]
        # create a start variable and assign it the value 0
        start = 0
        # this for loop will start at the number representing the total number of columns in the new matrix
        # the total number of columns in the matrix is the length of the sublists in the list
        # the total number of rows in the matrix is the length of the entire list
        # it will end at the total number of rows and columns plus 1 and will loop in increments of the number of columns
        # this allows us to loop through all of the values in the flattened list
        for end in range(c, (r*c)+1, c):
            # in the final list, we will append a slice of the flat list which represents the first row in the new matrix with
            # each value in this slice represents a columnn in the new matrix
            final_list.append(flat_list[start:end])
            # we will then increment the start variable by the value of c, so that we get the next row of the new matrix on the next loop
            start+=c
        # once we are done looping, our final list will be the new matrix that fits the dimensions of r*c
        return final_list
            
    # if the parameters given aren't possible to reshape the matrix, then we will output the original matrix just as the problem tell us to do
    else:
      return mat

# 387. First Unique Character in a String
# Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.

# import statement to create a dictionary of the count (value) of how many times each letter (key) appears in string s
from collections import Counter
class first_uniq_char:
  def firstUniqChar(self, s):
    # dictionary to count how many times each letter in string s appears
    count_dict = Counter(s)
    # uses enumerate to get the index of each loop along with each character in the string s
    for i, char in enumerate(s):
        # if the value of the character in the dictionary is 1, then it is the first unique letter so we will return the index i
        if count_dict[char] == 1:
            return i
    # if we get through the for loop without returning the index i, then we know there is no unique characters so we will return -1
    return -1