# -*- coding: utf-8 -*-
"""DSA_More_Leetcode_Practice.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D0bJtLlTRmBfYf9zOU9e3yWTa5sRO0JA
"""

# sort an array using merge sort

def merge_sort(arr):
    # when the array has length 1, we return that number
    if len(arr) <= 1:
        return arr
    # finds the midpoint of the array
    mid = len(arr) // 2
    # left half of the array divided on the midpoint
    left_half = arr[:mid]
    # right half of the array divided on the midpoint
    right_half = arr[mid:]
    # continues to divide the arrays until we get it down to an array with length 1, which will return the array
    # this uses recursion and will continue to happen before moving to the next line
    left_half = merge_sort(left_half)
    # same as above, uses recursion to divide the right half of the array until it gets to an array with length 1
    right_half = merge_sort(right_half)
    # once the recursion stops, we will use the merge function to merge the two arrays with length 1 together, then
    # every other array after that will again be merged using the merge function until we get back to the starting
    # point before the recursion started, which will be two sorted array (left and right) which will be merged
    return merge(left_half, right_half)

def merge(left, right):
    # empty result array to store the merge between left and right
    result = []
    # i is the index for left array
    i = 0
    # j is the index for right array
    j = 0
    # as long as the index for both left and right don't exceed their length, we will stay in the while loop
    while i < len(left) and j < len(right):
        # if the left array value at index i is less than or equal to the right array value at index j, we will append
        # the left value in the result array since its smaller. We will then move the i counter up by 1 to move to the next value
        # in the left array
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    # this adds the rest of the elements from the left or right array to the end of the result
    # the while loop will exit once we get to the end of either the right or left array, but this means that whatever array we didn't
    # get to the end of, then there will be more values left in it which we need to append to the end of result
    result.extend(left[i:])
    result.extend(right[j:])
    return result

# search for a target using binary search
def binary_search(arr, target):
    # represents the pointer for the index of the start of the array
    low = 0
    # represents the pointer for the index of the end of the array
    high = len(arr) - 1

    # as long as the array has a start and end index, continue the loop
    while low <= high:
        # midpoint of the array
        mid = (low + high) // 2

        # if the midpoint is equal to the target, return the midpoint since this will be the index
        if arr[mid] == target:
            return mid
        # if the midpoint is less than the target, change the low to the midpoint plus 1 since this will be
        # the start index of the new array
        elif arr[mid] < target:
            low = mid + 1
        # if the midpoint is greater than the target, change the high to the midpoint minus 1 since this will
        # be the end index of the new array
        else:
            high = mid - 1
    # if the value isn't found in the list return -1
    return -1

# Check if a string contains only unique characters

def unique_letters(input_string):
  # create a hash map for letters we have seen already
  seen_dict = {}
  # loop through each index and character
  for i, letter in enumerate(input_string):
    # if the letter is in the hash_map we return False
    if letter in seen_dict:
      return False
    # if the letter isn't in the hash map we add it
    else:
      seen_dict[letter] = i
  # if we get out of the for loop, we return True
  return True

# Leetcode 367. Valid Perfect Square

class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        # use a binary search approach since we know that if num is a perfect square,
        # then the value that makes it a perfect square is somewhere in the range between
        # 1 and the num, so we must efficiently look for that value
        # start with 1 as the low
        # and the num as the high
        low = 1
        high = num
        # find the midpoint between low and high
        mid = (high+low) // 2

        # while low isn't greater than high
        while low<=high:
            # if the middle^2 == num, then it's true since a whole number squared
            # will equal a perfect square
            if mid*mid == num:
                return True
            # if mid^2 is greater than the num, then we know that mid is too large
            # so we need to look at value less than it to determine if num is perfect square
            elif mid*mid > num:
                high = mid - 1
                mid = (high+low) // 2
            # if mid^2 is less than num, then we want to look at values greater than it
            # since we know that mid is too small
            elif mid*mid < num:
                low = mid + 1
                mid = (high+low) // 2
        # if we get out of the while loop because low is now greater than high
        # then we know that num isn't a perfect square so we return False
        return False

# Leetcode 153. Find Minimum in Rotated Sorted Array

class Solution:
    def findMin(self, nums: List[int]) -> int:
        # initialize our result at  index 0
        res = nums[0]
        # initialize our left, right, and mid pointers
        left = 0
        right = len(nums) - 1
        mid = len(nums) // 2
        # make sure left never gets bigger than right
        while left<=right:
            # if nums left is less than nums right then we have found our min
            # value since the array was rotated and once the left value is less than
            # the right then it means that the left value is the min
            if nums[left] < nums[right]:
                res = min(res, nums[left])
                break
            # here we use a simple binary search divide and conquer approach
            # updating the pointers and the res as we go through each iteration
            mid = (left + right) // 2
            res = min(res, nums[mid])
            if nums[mid] >= nums[left]:
                left = mid + 1
            else:
                right = mid - 1
        # eventually once, left equals or exceeds the value of right, then we looked through
        # the entire nums list using binary search and whatever
        # our res is will be the min of nums
        return res

# Leetcode 74. Search a 2D Matrix

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        # get the number of rows and columns in the matrix
        rows = len(matrix)
        cols = len(matrix[0])

        # starting point for the top and bottom row
        top_row = 0
        bottom_row = rows - 1

        # continue loop as long as the bottom row doesn't equal or exceed the top row
        # we will be using binary search to find the row our target would reside in
        # if it exists in the matrix
        while top_row <= bottom_row:
            # get the middle row of the matrix
            mid = (top_row + bottom_row) // 2
            # if the first value in the middle row of the matrix is greater than the target
            # then we want to search for values lower than it
            # so we make the bottom row the middle row plus 1
            if matrix[mid][0] > target:
                bottom_row = mid - 1
            # we make the top row the middle row plus 1 here
            elif matrix[mid][cols-1] < target:
                top_row = mid + 1
            # if the value is equal to the target then we can break since we found the correct
            # row that our target would be in if its exists
            else:
                break
        # once the top row becomes bigger than the bottom row
        # we exhausted our search so we can return False since the target
        # doesn't exist
        if not (top_row <= bottom_row):
            return False

        # if we get to here, this means we have found the correct row
        # that our target would be in if its exists
        target_row = (top_row + bottom_row) // 2
        # this time we will be looking for the actual value in each column of our row
        # using binary search technique
        low = 0
        high = cols - 1
        # while low isn't greater than or equal to high
        while low <= high:
            # get the midpoint
            mid = (low + high) // 2
            # if the value is less than the target, we want to search to the right
            if matrix[target_row][mid] < target:
                low = mid+1
            # if the value is greater than the target, we want to search to the left
            elif matrix[target_row][mid] > target:
                high = mid-1
            # if we find the target value then we can return true
            else:
                return True
        # if we make it all the way down here then the target doesn't exist and we
        # can return false
        return False

# Leetcode 143: Reorder list

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:

    def reorderList(self, head: Optional[ListNode]) -> None:
        slow = head
        fast = head.next
        #get to start of second half of list
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        # second half starts at slow.next
        second_half = slow.next
        # slow.next will break the link between first and second half
        slow.next = None

        # reverse the second list
        current = second_half
        previous = None
        while current:
            temp = current.next
            current.next = previous
            previous = current
            current = temp


        first = head
        second = previous
        # while second has contents in it
        while second:
            # temp variables to store next contents for first and second
            temp_first = first.next
            temp_sec = second.next
            # first.next will become the start of the second list
            first.next = second
            # second.next is now the temporary variable from first, which was originally first.next
            second.next = temp_first
            # first and second become the temp variables, both going to the next value in their list
            first = temp_first
            second = temp_sec

# Leetcode 23. Merge K-sorted lists

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        # if lists is empty, we just return None since there are no lists to merge
        if len(lists) == 0:
            return None
        # while loop to keep looping until we only have 1 list, which would be all the lists merged
        while len(lists) > 1:
            # initialize our empty list which we will put any merged lists in
            merged_list = []
            # for loop to loop through the lists array and grab two lists at a time
            for i in range(0,len(lists), 2):
                # assign list1 and list2
                list1 = lists[i]
                # if the list2 index is out of range, meaning theres an odd number of lists in the lists array
                # then we will make list2 None, otherwise list2 will be the list right after list1
                if (i+1) < len(lists):
                    list2 = lists[i+1]
                else:
                    list2 = None
                # call our merge_sort function to merge list1 and list2 and store them in our merged_list array
                merged_list.append(self.merge_sort(list1, list2))
            # change lists to be merged_list array after getting through the for loop
            # this will keep consolidating all lists until we break the while loop since len(lists) will be 1
            lists = merged_list
        # once all loops are done, we return the big merged and sorted list
        return lists[0]


    def merge_sort(self, list1, list2):
        # use a dummy variable which points to the node before the head
        dummy = ListNode()
        # create new variable current which is equal to dummy
        # this way we can increment the current value we are on without changing dummy
        # which we will need for later
        current = dummy
        # keep looping as long as list1 and list2 have elements in them
        while list1 and list2:
            # if the list1 value is smaller than or equal to list2 value
            # then we make the next value in our current list to the list1 value which is smaller
            if list1.val <= list2.val:
                # when we first start, current.next is really saying the value after dummy
                # which would be our head value
                current.next = list1
                list1 = list1.next
            # if list2 value is bigger, then we make the next value in our current list
            # to the list2 value which is smaller
            else:
                # when we first start, current.next is really saying the value after dummy
                # which would be our head value
                current.next = list2
                list2 = list2.next
            # after the if statement, we want the current value to go to the next value in either list1 or list2
            # so that we can do the comparison again on a new current value
            current = current.next

        # if list1 still has values, then we make the current.next value to
        # the rest of list1
        if list1:
            current.next = list1
        # if list2 still has values, then we make the current.next value to
        # the rest of list2
        elif list2:
            current.next = list2

        # once we reach the end, we return the head of our merged and sorted list by using our dummy
        # variable which is the previous value before head and returning dummy.next which is head
        return dummy.next

# Leetcode 2. Add Two Numbers

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        # create a dummy node which will come in handy at the end
        dummy = ListNode()
        # initialize current to the dummy so that we still have dummy
        # when we get to the end, since we need dummy.next to give
        # us the head of the new linked list we are about to create
        current = dummy
        # create a variable called carry over for if we get values
        # that are between 10 and 19
        carry_over = 0
        # as long as l1 and l2 are not empty we continue the loop
        while l1 or l2:
            # if both arent empty then we add the two values
            # at the same indexes plus the carry_over
            # then go to the next values in both
            if l1 and l2:
                new_val = l1.val + l2.val + carry_over
                l1 = l1.next
                l2 = l2.next
            # if only l1 isn't empty, then we add the l1 value to carry_over
            # and go to the next value in l1
            elif l1:
                new_val = l1.val + carry_over
                l1 = l1.next
            # if only l2 isn't empty, then we add the l2 value to carry_over
            # and go to the next value in l2
            elif l2:
                new_val = l2.val + carry_over
                l2 = l2.next
            # if the value is greater than or equal to 10, then we have to subtract it by 10
            # replace the current.next with the new value, and add 1 to the carry over
            if new_val >= 10:
                current.next = ListNode(new_val - 10)
                carry_over = 1
            # if the value is less than 10, then we add the new val to the current.next spot
            # and then set carry_over to 0 since we have nothing to carry over
            else:
                current.next = ListNode(new_val)
                carry_over = 0
            # we set current to the current.next
            current = current.next

        # once we get through the list, we need to make sure our carry over doesn't
        # have a value in it. If it does, we add it to current next
        if carry_over > 0:
            current.next = ListNode(carry_over)
        # we finally return dummy.next which will be the head of the new linked
        # list we just created
        return dummy.next

# Leetcode 24: Swap Nodes in Pairs

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(next = head)
        current = head
        previous = dummy
        while current and current.next:
            # save variables
            second = current.next
            next_pair = current.next.next

            # the second node will become the first, so we set its next pointer to the first which is current
            second.next = current
            # the current node will now be the second node, so we need to set its next pointer to the next pair
            current.next = next_pair
            # we now want the previous node to have its next pointer to what is now the first node
            previous.next = second
            previous = current
            current = next_pair
        return dummy.next

# Leetcode 86

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:
        # initialize our less than list, this will be the head
        less_list = ListNode()
        # initialize our greater than list, this will be the head
        great_list = ListNode()
        # our tail pointers will always be the end of each list
        less_tail = less_list
        great_tail = great_list

        # while head is not null
        while head:
            # if the head value is less than x
            if head.val < x:
                # we need to establish a pointer for our tail to the head
                less_tail.next = head
                # now we can set the tail to less_tail.next which is the head
                less_tail = less_tail.next
            else:
                # we need to establish a pointer for our tail to the head
                great_tail.next = head
                # now we can set the tail to great_tail.next which is the head
                great_tail = great_tail.next
            # go to the next value in the original list
            head = head.next
        # once we reach the end of the original list, the last value in less list has to
        # point next to the head of great list
        less_tail.next = great_list.next
        # the last value in great list has to point to None
        great_tail.next = None
        # we must return the head of less list
        return less_list.next

# Leetcode 61: Rotate List

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # if the linked list is empty, then no matter how much we rotate it will
        # be the same, so we can just return head
        if not head:
            return head

        # set tail equal to the head
        tail = head
        # set length = 1
        length = 1
        # continue the loop as long as tail.next isn't empty
        # here we are getting the length of our linked list
        while tail.next:
            tail = tail.next
            length+=1

        # k mod length will give us how many times we need to rotate
        # so that we can only rotate once efficiently, instead
        # of rotating many times
        k = k % length
        # if the k is now 0, then we don't have to rotate at all so we return head
        if k == 0:
            return head

        # this gives us how much we have to move to the right to
        # complete the rotation
        move_over = length - k - 1
        # set current to the head
        current = head
        # while move over isn't 0, we are going to set current to current.next
        # and decrement move over by 1
        # we will eventually get to the node that will be last in the new rotated list
        # which will be current
        while move_over:
            current = current.next
            move_over-=1

        # our new head for the rotated list will be the current next
        # since current is our new last element
        new_head = current.next
        # we will break the link at current.next since it's the new head and shouldn't
        # have any link before it
        current.next = None
        # the last element in the original list will now get linked to the original head
        tail.next=head
        # new head will be returned giving the rotated linked list we just created
        return new_head

# Leetcode 226: Invert Binary Tree
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # if theres no root we return None
        if not root:
            return None
        # save the left root as a temp variable
        tmp = root.left
        # make the left root the right root
        root.left = root.right
        # make the right root the temp, which was originally left root
        root.right = tmp
        # call the same function recursively using the left and right children
        # as the new roots
        # it will break out once we get to the end of the tree when there are no children
        # so root will be None
        self.invertTree(root.left)
        self.invertTree(root.right)

        # return the tree which is now inverted
        return root

# Leetcode 100: Same tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        # base case for recursion. If p and q both don't exist, we can return true
        if not p and not q:
            return True
        # if only 1 of the values are the current level doesn't exist, return false
        # since this means they aren't the same
        if not p or not q:
            return False
        # if both have values at the current level, but the values differ, return False
        if p.val != q.val:
            return False
        # we will call the function recursively by going to the left and right children
        # for both nodes p and q. If both end up being True at the end of the recursion
        # then they are identical. If only 1 or both are false, then they aren't identical
        return (self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right))

# Leetcode 235. Lowest Common Ancestor of a Binary Search Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # set current to the root
        current = root
        # continue the loop as long as current is not null
        while current:
            # if the value of p and q is greater than current
            if p.val > current.val and q.val > current.val:
                # go to the right since only values to the right
                # in a a binary search tree satisfy this
                current = current.right
            # if p and q are smaller than the current
            elif p.val < current.val and q.val < current.val:
                # go to the left since this is a binary search tree
                current = current.left
            # otherwise return current since this is a binary search tree
            # so current will be the LCA based on the definition of BST
            else:
                return current

# Leetcode 617. Merge Two Binary Trees

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        # if there's no root1 and root2
        # we return none. This is a base case
        if not root1 and not root2:
            return None

        # if root 1 exists we store its value
        if root1:
            r1_val = root1.val
        # if it doesn't exist we store it's value as 0
        else:
            r1_val = 0
        # if root 2 exists we store its value
        # if it doesn't exist we store it's value as 0
        if root2:
            r2_val = root2.val
        else:
            r2_val = 0

        # we create a new Node where we add up node 1 and node 2 values
        # and store it as root
        root = TreeNode(r1_val + r2_val)
        # we then use recursion to iterate all through each node in root1 and root1
        # will do all left nodes one by one, then once it reaches the last left and is done,
        # it will go back one by one and do each right node one by one
        # then it will be done merging the trees
        # (start) --> (left), right --> (left), right --> (left), right --> done left -->
        # (left), (right) --> (left), (right) --> (left), (right) --> done right --> done problem return root
        root.left = self.mergeTrees(root1.left if root1 else None, root2.left if root2 else None)
        root.right = self.mergeTrees(root1.right if root1 else None, root2.right if root2 else None)
        # return the root of the merged tree we just created
        return root

# Leetcode 1448. Count Good Nodes in Binary Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        # count will initially be 1 since the root is always a good node
        count = 1
        # max root is initialized to the value of the root
        max_root = root.val
        # we want to call our count good function which will count the number of good nodes
        return self.count_good(root, count, max_root)


    def count_good(self, root, count, max_root):
        # if the root is None, then we return the count
        if not root:
            return count
        # if there is no right or left from the root, then we return count since we cant branch
        # down anymore meaning we reached a leaf node
        if not root.right and not root.left:
            return count
        # if the root left exists
        if root.left:
            # we want to find the max between the current max_root and the root left value
            # this way every time we go to a left path, we are saving the highest value we saw from that path
            max_root_left = max(max_root, root.left.val)
            # if the current value in our left path is greater than or equal to the max value we've seen so far in
            # the current path, then we increment by 1
            if root.left.val >= max_root_left:
                count+=1
        # if there is no root.left then our max node we've seen in our path just stays as the current max_root
        else:
            max_root_left = max_root

        # if the root right exists
        if root.right:
            # we want to find the max between the current max_root and the root right value
            # this way every time we go to a right path, we are saving the highest value we saw from that path
            max_root_right = max(max_root, root.right.val)
            # if the current value in our right path is greater than or equal to the max value we've seen so far in
            # the current path, then we increment by 1
            if root.right.val >= max_root_right:
                count+=1
        # if there is no root.right then our max node we've seen in our path just stays as the current max_root
        else:
            max_root_right = max_root

        # here we are using recursion. We update count after each time we go left and right, so that
        # if we find any good nodes when going in a left path or right path we count them
        # we also pass max_root_left and max_root_right to each function, which will become the max_root
        # when the function starts. We also pass the current count in for both
        count = self.count_good(root.left, count, max_root_left)
        count = self.count_good(root.right, count, max_root_right)
        # once we reach the end, our count should be fully updated so we return it
        return count

# Leetcode 1448. Count Good Nodes in Binary Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        # define a function for depth first search in our goodNodes function
        def dfs(root, max_val):
            # if the root is non-existant
            # return 0 as a base case
            if not root:
                return 0
            # if the value of the current root is greater than our max value
            # we set count to 1, otherwise count is 0
            # count will count the number of good nodes as defined in the problem
            if root.val >= max_val:
                count = 1
            else:
                count = 0
            # we then recompute our max val by taking the max
            # of the current root value and the current max value
            max_val = max(root.val, max_val)
            # we then add the dfs function back to the our count
            # we check both the left and right of the root
            # with checking all the lefts first, then the rights
            count += dfs(root.left, max_val)
            count += dfs(root.right, max_val)
            # once we get through all nodes we return our count of good nodes
            return count
        # here we will be returning our dfs function with the root as the root
        # and the root.val as the max_val we have seen so far in the path
        # this will return the count of good nodes when all is finished
        return dfs(root, root.val)

# Leetcode 108. Convert Sorted Array to Binary Search Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        # base case, if there is no value in nums we return None since there can't be a tree node made
        if not nums:
            return None
        # if there is 1 number in nums, the TreeNode becomes that number
        if len(nums) == 1:
            return TreeNode(val = nums[0])
        # find the middle of nums
        middle = len(nums) // 2

        # create a Tree Node from the middle and set it to current
        current = TreeNode(val = nums[middle])
        # set current left to the recursive function and make nums the first half of nums
        current.left = self.sortedArrayToBST(nums = nums[:middle])
        # set current right to the recursive function and make nums the second half of nums
        current.right = self.sortedArrayToBST(nums = nums[middle+1:])
        # return whatever the current node is
        return current

# Leetcode 98. Validate Binary Search Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        # create a function inside our function which we will call recursively
        # inputs will be the current node, left of the node, and right of the node
        def check_valid(node, left, right):
            # base case for if there's no node
            # we return true
            if not node:
                return True
            # if the nod.val is not less than right and it's not greater than left
            # we return false. This is the basic definition for a BST
            if not (node.val < right and node.val > left):
                return False
            # we will return the check_valid function for the left and right of the
            # current node. These will check if the binary tree is a valid BST
            # if both are valid then it will return true. If only 1 is not valid BST
            # it will return False
            return(check_valid(node.left, left, node.val) and check_valid(node.right, node.val, right))
        # we will return our check valid function, with the root, negative infinity,
        # and positive infinity as inputs
        # the reason we include negative and positive infinity
        # is because we are first checking the root node, and just a root node
        # will always be a BST. We need to check the children of the root
        # to assess if it's still a valid BST
        return check_valid(root, float("-inf"), float("inf"))

# Leetcode 49. Group Anagrams

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        # hash map to store our lists of anagrams
        hash_map = {}
        # loop through each word in the strs list
        for word in strs:
            # sort each word and put it into a string
            word_sort = "".join(sorted(word))
            # if the sorted word is not in the hash_map, put it in the hash_map
            if word_sort not in hash_map:
                hash_map[word_sort] = [word]
            # if the sorted word is in the hash_map, append the current word
            # from strs in the hash_map
            else:
                hash_map[word_sort].append(word)
        # return only the values from the hash_map once the loop finishes
        return hash_map.values()

# Leetcode 102. Binary Tree Level Order Traversal

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    from collections import deque
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        # intitialize our queue
        queue = deque()
        # output list
        output = []
        # append the root to our queue
        queue.append(root)
        # while our queue has values in it
        while queue:
            # get length of queue
            queue_len = len(queue)
            # intitialize level list for each level in the tree
            level = []
            # for loop to loop through each level in the tree
            for i in range(queue_len):
                # pop left most node and set to current
                current = queue.popleft()
                # if current is not null then we will append the current.val
                # to level list and also add current.left and current.right to queue
                # this will also prevent trying to get left and right of a null node
                # since our if statement checks if the node is null before doing so
                if current:
                    level.append(current.val)
                    queue.append(current.left)
                    queue.append(current.right)
                print(level)
            # makes sure that our level list we are appending to output is not empty
            # the level list could be empty due to us not appending anything because of null
            # nodes not allowing us to pass "if current"
            # after each for loop level automatically goes back to empty
            if level:
                output.append(level)
        # we return the output list once we are out of the while loop
        return output

# Leetcode 118. Pascal's Triangle

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        # initialize result array
        res = [[1]]
        # loop through each row
        for i in range(1, numRows):
            # j is our second index
            j = 1
            # fill in the array at each level
            # with all 0s besides for the first and last element
            res += [[0]*(i+1)]
            res[i][0] = 1
            res[i][-1] = 1
            # while loop to fill in elements in each row skipping the first
            # and stopping before the last
            while j < len(res[i]) - 1:
                res[i][j] = res[i-1][j-1] + res[i-1][j]
                # increment j by 1 to move along in the array
                j+=1
        # return the result
        return res

# Leetcode 64. Minimum Path Sum

class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        # get the rows and columns of the grid
        rows = len(grid)
        cols = len(grid[0])
        # create a new matrix with 1 row and 1 column bigger than the original grid
        # and fill it in with infinity values
        matrix = [[float('inf') for _ in range(cols+1)] for _ in range(rows+1)]
        # make the last row and second to last column 0
        # this will be the position directly under the bottom right value
        # in the original grid
        matrix[rows][cols-1] = 0
        # iterate through each (row-1) in our matrix
        for row in range(rows - 1, -1, -1):
            # iterate through each (col-1) in our matrix
            for col in range(cols - 1, -1, -1):
                # the new value will be the grid value in that position plus
                # the minimum of the value in the matrix below it and to the right of it
                matrix[row][col] = grid[row][col] + min(matrix[row+1][col], matrix[row][col+1])
        # return the top left position in our matrix for the answer
        return matrix[0][0]

# Leetcode 256. Paint House

class Solution:
    def minCost(self, costs: List[List[int]]) -> int:
      # initialize our array which will keep track of the cost of
      # painting each house
      dp = [0, 0, 0]
      # iterate through each value in the costs array
      for i in range(len(costs)):
        # we set dp0 to the current costs array at index 0
        # we do this for dp1 and dp2 at their respective indexes
        # then we take the minimum of the values before that are not the same index
        # since if you paint a house in say index 1, you cant paint the next house in index 1, it has to be index 0 or index 2
        dp0 = costs[i][0] + min(dp[1], dp[2])
        dp1 = costs[i][1] + min(dp[0], dp[2])
        dp2 = costs[i][2] + min(dp[0], dp[1])
        # we then set the dp array to have the dp1, dp2, and dp3 we calculated
        # this will allow us to then take these values and add them in our next for loop iteration
        dp = [dp1, dp2, dp3]
      # once we get to the end, we will have added up all the possibilities for the minimum of each paint cost
      # so we want to take the minimum of all the values we computed and return it
      return min(dp)

# Leetcode 139. Word Break

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        # initialize our cache (1d array) to tell us at which index we have a word
        # that matches something in wordDict
        dp = [False] * (len(s) + 1)
        # set the very end of our cache list to True, since we know that if
        # we get to the last element in our array then we completed the problem successfully
        dp[len(s)] = True
        # iterate through every letter in our string s starting from the end
        for i in range(len(s)-1, -1, -1):
            # also for every letter in string s, we need to try and match it with
            # a word from the wordDict
            for word in wordDict:
                # checks to see if the string s has enough characters
                # for us to compare word to it, it then also wants to check if
                # s sliced at the specified index is equal to the word
                if (i+len(word)) <= len(s) and s[i:i+len(word)] == word:
                    # update our dp at index i to the dp value of the index at the end of
                    # the word we just matched
                    dp[i] = dp[i+len(word)]
                # if the index is True, we break out of the loop since we now know
                # that we can match a word from wordDict at the specific index
                if dp[i]:
                    break
        # return the first index in dp since this will tell us if we are
        # able to make the whole entire string s using the words in the wordDict
        return dp[0]

# Leetcode 152. Maximum Product Subarray

class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        # set our max_product equal to the max of nums, since if nums only has
        # one value, then we will be capturing that through this step
        result = max(nums)
        # setting these equal to 1 to start, we will see as we go on
        # that we always want these to be 1 and not 0, since anything times
        # 0 is 0
        cur_min = 1
        cur_max = 1
        # loop through each value in nums
        for num in nums:
            # create the cur_max*num temp variable so we don't lose this value after
            # recomputing cur_max before cur_min below
            temp = cur_max * num
            # the cur_max could either be num*cur_max (when both vals are positive)
            # or could be num*cur_min when one val is positive and the other is negative
            # or could simply just be num by itself
            cur_max = max(num*cur_max, num*cur_min, num)
            # the cur_min could also be any of these 3 values
            cur_min = min(temp, num*cur_min, num)
            # after computing the min and max, we want to update the result
            result = max(result, cur_min, cur_max)
        # once we get through the for loop for the entire array, we return result
        return result

# Leetcode 567. Permutation in String

class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        # immedietly return False if s1 length is greater than s2 length
        # since this means that we can find any permuations in s2 to make s1
        if len(s1) > len(s2):
            return False
        # initialize start and end which will be the window of values
        # we will be checking in s2
        start = 0
        end = len(s1)
        # create hash map for the values in s1 and for the values in the window of s2
        # the values in the window of s2 will be 1 before end but not include it
        s1_hash = collections.Counter(s1)
        s2_hash = collections.Counter(s2[:end])
        print(s1_hash)
        print(s2_hash)
        # while our end value isn't greater than length of s2
        while end < len(s2):
            # if the two dictionaries are the same
            # this means we have found a permutation
            if s1_hash == s2_hash:
                return True
            # if they aren't the same, then we decrement the value for the hash
            # of the key for s2[start] since we will now be incrementing our window
            # by 1 and no longer including that key-value pair instance in our hash map
            s2_hash[s2[start]] -= 1
            # if our end value already exists in the hash map, we add 1 to it
            # if it doesn't exist, we give it value 0 and add 1 to it
            s2_hash[s2[end]] = s2_hash.get(s2[end], 0) + 1
            # increment our window by 1 so we can check the next window of values
            # to see if they equal s1
            # our end after this operation will be the index of the character in s2 that we
            # need to add next to our hash map,
            # which will happen once we reach the line of code above
            end += 1
            start += 1
        # if at the end, the two hash maps are the same this will return True since
        # this means s1==s2. If they are not the same it will return False since s1!=s2
        return s1_hash == s2_hash

# dfs iteratively

def dfs(self, root):
        # if we have no root, we return nothing
        if root is None:
            return

        # create our stack array
        stack = []
        # append the root to the stock
        stack.append(root)
        # create an empty dfs array which will we will append our visited nodes
        dfs = []
        # while the stack is not empty, we continue the loop
        while stack:
            # pop the first element from the stack
            current = stack.pop()
            # append its value to the dfs array
            dfs.append(current.val)

            # Since it's a depth-first search, we push the right child first
            # then the left child. And if there's not a left but there is a right we append None
            if current.right:
                stack.append(current.right)
            if current.left:
                stack.append(current.left)
            if not current.left and current.right:
                dfs.append(None)
        # return the dfs visited array to tell us the dfs order in which the nodes were visited
        return dfs

# Breadth First Search

def bfs(current):
            # create a visited set
            visited = set()
            # create a queue and append the current element to it
            queue = deque()
            queue.append(current)

            # while the queue isn't empty
            while queue:
                # we will pop the left most element from the queue
                # and set it to current
                current = queue.popleft()
                # if the current isn't in the visited set
                # we will add it
                if current not in visited:
                    visited.add(current)
                # if current left is not null
                # we add that to the queue
                if current.left:
                    queue.append(current.left)
                # if current right is not null
                # we add it to the queue
                if current.right:
                    queue.append(current.right)
            # return the visited set which will give the nodes
            # in breadth first search order
            return visited